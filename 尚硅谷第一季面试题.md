# 尚硅谷第一季面试题

## 自增变量

```java
    public static void main(String[] args) {

        int i = 1;
        i = i++;
        int j = i++;
        int k = i + ++i * i++;
        System.out.println("i=" + i);
        System.out.println("j=" + j);
        System.out.println("k=" + k);

//        答案
//        i=4
//        j=1
//        k=11

    }
```

- 赋值=，最后计算
- =右边的从左到右加载值依次压入操作数栈
- 实际先算哪个，看运算符优先级
- 自增、自减操作都是直接修改变量的值，不经过操作数栈
- 最后的赋值之前，临时结果也是存储在操作数栈中

## 单例设计模式

- 设计要点
  - 只能有一个实例
  - 必须自行创建实例
  - 必须自行向系统提供这个实例
- `Runtime`类就是一个单例，一个JVM只有一个这种类的实例
- 常见的设计形式
  - 饿汉式：都是线程安全的
    - 枚举式
    - 直接实例化
    - 静态代码块：和直接实例化一样，都是在类加载的时候创建实例。但是在代码块中，可以有更复杂的初始化逻辑，比如从配置文件中获取值赋给实例。
  - 懒汉式
    - 线程不安全（适用于单线程）
    - 线程安全（适用于多线程）
    - 静态内部类形式（适用于多线程）：在内部类被加载和初始化的时候，才创建实例

## 初始化

- 类的初始化过程
  - 一个类要创建实例需要先加载并初始化该类
    - main方法所在的类需要先加载和初始化
  - 一个子类要初始化，需要先初始化父类
  - 一个类初始化就是执行`<clinit>()`方法
    - `<clinit>()`方法由**静态变量显式赋值**和**静态代码块**组成
    - 类变量显式赋值代码和静态代码块代码从上到下顺序执行
    - `<clinit>()`方法只执行一次
- 实例的初始化过程
  - 执行`<init>()`方法
    - `<init>()`方法的数量和构造器的数量一样
    - `<init>()`方法由**非静态实例变量显式赋值代码**和**非静态代码块**、对应的**构造器代码**组成
    - **非静态实例变量显式赋值代码**和**非静态代码块代码**从上到下顺序执行，对应的**构造器的代码**最后执行
    - 每次创建实例对象，调用对应构造器，执行的就是对应的`<init>()`方法
    - `<init>()`方法的首行是`super()`或`super(实参列表)`，即对应父类的`<init>()`方法
- 方法的重写
  - 那些方法不可以被重写
    - final方法
    - 静态方法
    - private等子类中不可见方法
  - 对象的多态性
    - 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码
    - 非静态方法默认的调用对象是`this`
    - this对象在构造器或者`<init>()`方法中就是正在创建的对象

## 方法的参数传递机制

- 形参是`基本`数据类型，则传递`数据值`
- 形参是`引用`数据类型，则传递`地址值`
  - String、包装类（比如Integer）等对象具有`不可变性`。就是说，修改之后会创建新的对象，有新的地址值

## 递归与迭代

- 递归
  - 优点：大问题转化为小问题，可以减少代码量，可读性好。
  - 缺点：递归调用浪费了空间，而且递归太深容易造成堆栈的溢出
- 迭代
  - 优点：代码运行效率好，因为时间只因循环次数增加而增加，而且没有额外的空间开销
  - 缺点：代码不简洁，可读性较差

## 成员变量与局部变量

- 就近原则
- 变量的分类
  - 成员变量
    - 类变量：有`static`修饰
    - 实例变量
  - 局部变量
- 非静态代码块的执行：每次创建实例对象都会执行
- 方法的调用规则：调用一次执行一次
- 局部变量和成员变量的区别
  - 声明的位置
    - 局部变量
      - 方法体中
      - 代码块中
      - 形式参数中
    - 成员变量
      - 类中方法外
  - 修饰符
    - 局部变量：final
    - 成员变量：public protected private final static volatile transient
  - 值存储的位置
    - 局部变量：栈
    - 实例变量：堆
    - 类变量：方法区
  - 作用域
  - 生命周期
    - 局部变量：每一个线程，每一次调用执行都是新的声明周期
    - 实例变量：随对象创建而生，随对象回收而亡
    - 类变量：随类初始化而生，随类卸载而亡

## Spring Bean的作用域

- singleton：单例，**创建IOC容器的时候就被创建**
- prototype：有调用才创建，每次调用都创建新的
- request：每次请求都创建新的
- session：在一个session中共享

## Spring的事务传播属性和事务隔离级别

## SpringMVC中中文乱码怎么解决

- Post请求：配置一个过滤器
- Get请求：在Tomcat配置里，在`Connector`标签中加入`URIEncoding=UTF8`

## Mybatis中，类中的属性名和表中的字段名不一致怎么办

- 写SQL语句的时候起个别名
- 在Mybatis的全局配置文件中开启驼峰命名
- 在Mapper映射文件中配置`resultMap`

## git分支相关命令

- 创建分支
  - git branch branchName
  - git branch -v 查看分支
- 切换分支
  - git checkout branchName
  - 创建加切换一步到位：git checkout -b branchName
- 合并分支
  - git merge branchName
- 删除分支
  - git branch -D branchName

## redis持久化

- RDB
  - 原理：在间隔时间内，对当前数据进行快照备份
  - 备份如何执行：使用备份文件的时候，先fork另外一条线程，不打扰工作主线程进行，新的线程进行持久化操作，执行完成后，将本次持久化的文件替换上次持久化的文件
  - 优点
    - 节省磁盘空间
    - 恢复速度快
  - 缺点
    - 数据太大时，会耗费性能
    - 备份周期在一定间隔时间做一次备份，如果redis意外down掉，就会丢失最后一次快照后的所有修改
- AOF
  - 原理：以日志的形式来记录每个写操作
  - 优点
    - 备份机制更稳健，丢失数据的概率更低，粒度更小
  - 缺点
    - 更占磁盘空间
    - 恢复速度比较慢
    - 同步过于频繁的话，有性能压力

## Mysql建索引

- 索引是一种数据结构
- 索引的优点
  - 检索效率快 
  - 排序效率高
- 索引的缺点
  - 插入的时候要维护相对应的索引，降低速度
  - 占用空间
- 什么情况需要建索引
  - 频繁作为查询条件字段的应该建立索引
  - 与其他表有关联的字段应该建索引
  - 经常作为排序和分组条件的字段
- 不要建立索引的情况
  - 表记录太少
  - 经常增删改的字段
  - 检索条件用不到的
  - 过滤性不好的字段（比如性别，就男和女）

## 垃圾回收机制

- GC是发生在`heap（堆）`里面的
- 有几种GC
  - Minor GC：发生在Young区，次数频繁
  - Full GC：发生到Old区，次数较少
- GC算法
  - 引用计数
  - 复制
    - Minor GC 大多数采用的是复制算法
    - 需要占用的空间较大
    - 没有内存碎片
  - 标记-清除
    - Full GC 一些采用这种算法
    - 占用空间较小
    - 有内存碎片
  - 标记-整理
    - Full GC 一些采用这种算法
    - 标记-清除-压缩
    - 没有内存碎片
    - 相对于标记-清除，多了压缩，就是多了移动对象的成本

## redis的使用场景

- Set：取好友交集
- Zset：排名

## 单点登录

- 概念：一处登陆，多处使用，多使用在分布式系统中
- 核心：登陆的时候生成token，绑定用户信息，token随着cookie，应用页面在cookie中获取token，获取用户信息

## 购物车

- 存在哪里
  - 用户已登陆
    - redis
    - cookie
    - LocalStorge
  - 用户已登陆
    - redis：用Hash结构
    - mysql